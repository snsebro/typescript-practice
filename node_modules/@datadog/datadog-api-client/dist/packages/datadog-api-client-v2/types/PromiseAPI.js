"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseUsersApi = exports.PromiseSecurityMonitoringApi = exports.PromiseRolesApi = exports.PromiseProcessesApi = exports.PromiseMetricsApi = exports.PromiseLogsMetricsApi = exports.PromiseLogsArchivesApi = exports.PromiseLogsApi = exports.PromiseKeyManagementApi = exports.PromiseIncidentsApi = exports.PromiseIncidentTeamsApi = exports.PromiseIncidentServicesApi = exports.PromiseDashboardListsApi = void 0;
var ObservableAPI_1 = require("./ObservableAPI");
var PromiseDashboardListsApi = /** @class */ (function () {
    function PromiseDashboardListsApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_1.ObservableDashboardListsApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Add dashboards to an existing dashboard list.
     * Add Items to a Dashboard List
     * @param dashboardListId ID of the dashboard list to add items to.
     * @param body Dashboards to add to the dashboard list.
     */
    PromiseDashboardListsApi.prototype.createDashboardListItems = function (dashboardListId, body, options) {
        var result = this.api.createDashboardListItems(dashboardListId, body, options);
        return result.toPromise();
    };
    /**
     * Delete dashboards from an existing dashboard list.
     * Delete items from a dashboard list
     * @param dashboardListId ID of the dashboard list to delete items from.
     * @param body Dashboards to delete from the dashboard list.
     */
    PromiseDashboardListsApi.prototype.deleteDashboardListItems = function (dashboardListId, body, options) {
        var result = this.api.deleteDashboardListItems(dashboardListId, body, options);
        return result.toPromise();
    };
    /**
     * Fetch the dashboard listâ€™s dashboard definitions.
     * Get items of a Dashboard List
     * @param dashboardListId ID of the dashboard list to get items from.
     */
    PromiseDashboardListsApi.prototype.getDashboardListItems = function (dashboardListId, options) {
        var result = this.api.getDashboardListItems(dashboardListId, options);
        return result.toPromise();
    };
    /**
     * Update dashboards of an existing dashboard list.
     * Update items of a dashboard list
     * @param dashboardListId ID of the dashboard list to update items from.
     * @param body New dashboards of the dashboard list.
     */
    PromiseDashboardListsApi.prototype.updateDashboardListItems = function (dashboardListId, body, options) {
        var result = this.api.updateDashboardListItems(dashboardListId, body, options);
        return result.toPromise();
    };
    return PromiseDashboardListsApi;
}());
exports.PromiseDashboardListsApi = PromiseDashboardListsApi;
var ObservableAPI_2 = require("./ObservableAPI");
var PromiseIncidentServicesApi = /** @class */ (function () {
    function PromiseIncidentServicesApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_2.ObservableIncidentServicesApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Creates a new incident service.
     * Create a new incident service
     * @param body Incident Service Payload.
     */
    PromiseIncidentServicesApi.prototype.createIncidentService = function (body, options) {
        var result = this.api.createIncidentService(body, options);
        return result.toPromise();
    };
    /**
     * Deletes an existing incident service.
     * Delete an existing incident service
     * @param serviceId The ID of the incident service.
     */
    PromiseIncidentServicesApi.prototype.deleteIncidentService = function (serviceId, options) {
        var result = this.api.deleteIncidentService(serviceId, options);
        return result.toPromise();
    };
    /**
     * Get details of an incident service. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident services.
     * Get details of an incident service
     * @param serviceId The ID of the incident service.
     * @param include Specifies which types of related objects should be included in the response.
     */
    PromiseIncidentServicesApi.prototype.getIncidentService = function (serviceId, include, options) {
        var result = this.api.getIncidentService(serviceId, include, options);
        return result.toPromise();
    };
    /**
     * Get all incident services uploaded for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident services.
     * Get a list of all incident services
     * @param include Specifies which types of related objects should be included in the response.
     * @param pageSize Size for a given page.
     * @param pageOffset Specific offset to use as the beginning of the returned page.
     * @param filter A search query that filters services by name.
     */
    PromiseIncidentServicesApi.prototype.listIncidentServices = function (include, pageSize, pageOffset, filter, options) {
        var result = this.api.listIncidentServices(include, pageSize, pageOffset, filter, options);
        return result.toPromise();
    };
    /**
     * Updates an existing incident service. Only provide the attributes which should be updated as this request is a partial update.
     * Update an existing incident service
     * @param serviceId The ID of the incident service.
     * @param body Incident Service Payload.
     */
    PromiseIncidentServicesApi.prototype.updateIncidentService = function (serviceId, body, options) {
        var result = this.api.updateIncidentService(serviceId, body, options);
        return result.toPromise();
    };
    return PromiseIncidentServicesApi;
}());
exports.PromiseIncidentServicesApi = PromiseIncidentServicesApi;
var ObservableAPI_3 = require("./ObservableAPI");
var PromiseIncidentTeamsApi = /** @class */ (function () {
    function PromiseIncidentTeamsApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_3.ObservableIncidentTeamsApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Creates a new incident team.
     * Create a new incident team
     * @param body Incident Team Payload.
     */
    PromiseIncidentTeamsApi.prototype.createIncidentTeam = function (body, options) {
        var result = this.api.createIncidentTeam(body, options);
        return result.toPromise();
    };
    /**
     * Deletes an existing incident team.
     * Delete an existing incident team
     * @param teamId The ID of the incident team.
     */
    PromiseIncidentTeamsApi.prototype.deleteIncidentTeam = function (teamId, options) {
        var result = this.api.deleteIncidentTeam(teamId, options);
        return result.toPromise();
    };
    /**
     * Get details of an incident team. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident teams.
     * Get details of an incident team
     * @param teamId The ID of the incident team.
     * @param include Specifies which types of related objects should be included in the response.
     */
    PromiseIncidentTeamsApi.prototype.getIncidentTeam = function (teamId, include, options) {
        var result = this.api.getIncidentTeam(teamId, include, options);
        return result.toPromise();
    };
    /**
     * Get all incident teams for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident teams.
     * Get a list of all incident teams
     * @param include Specifies which types of related objects should be included in the response.
     * @param pageSize Size for a given page.
     * @param pageOffset Specific offset to use as the beginning of the returned page.
     * @param filter A search query that filters teams by name.
     */
    PromiseIncidentTeamsApi.prototype.listIncidentTeams = function (include, pageSize, pageOffset, filter, options) {
        var result = this.api.listIncidentTeams(include, pageSize, pageOffset, filter, options);
        return result.toPromise();
    };
    /**
     * Updates an existing incident team. Only provide the attributes which should be updated as this request is a partial update.
     * Update an existing incident team
     * @param teamId The ID of the incident team.
     * @param body Incident Team Payload.
     */
    PromiseIncidentTeamsApi.prototype.updateIncidentTeam = function (teamId, body, options) {
        var result = this.api.updateIncidentTeam(teamId, body, options);
        return result.toPromise();
    };
    return PromiseIncidentTeamsApi;
}());
exports.PromiseIncidentTeamsApi = PromiseIncidentTeamsApi;
var ObservableAPI_4 = require("./ObservableAPI");
var PromiseIncidentsApi = /** @class */ (function () {
    function PromiseIncidentsApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_4.ObservableIncidentsApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Create an incident.
     * Create an incident
     * @param body Incident payload.
     */
    PromiseIncidentsApi.prototype.createIncident = function (body, options) {
        var result = this.api.createIncident(body, options);
        return result.toPromise();
    };
    /**
     * Deletes an existing incident from the users organization.
     * Delete an existing incident
     * @param incidentId The UUID the incident.
     */
    PromiseIncidentsApi.prototype.deleteIncident = function (incidentId, options) {
        var result = this.api.deleteIncident(incidentId, options);
        return result.toPromise();
    };
    /**
     * Get the details of an incident by `incident_id`.
     * Get the details of an incident
     * @param incidentId The UUID the incident.
     * @param include Specifies which types of related objects should be included in the response.
     */
    PromiseIncidentsApi.prototype.getIncident = function (incidentId, include, options) {
        var result = this.api.getIncident(incidentId, include, options);
        return result.toPromise();
    };
    /**
     * Get all incidents for the user's organization.
     * Get a list of incidents
     * @param include Specifies which types of related objects should be included in the response.
     * @param pageSize Size for a given page.
     * @param pageOffset Specific offset to use as the beginning of the returned page.
     */
    PromiseIncidentsApi.prototype.listIncidents = function (include, pageSize, pageOffset, options) {
        var result = this.api.listIncidents(include, pageSize, pageOffset, options);
        return result.toPromise();
    };
    /**
     * Updates an incident. Provide only the attributes that should be updated as this request is a partial update.
     * Update an existing incident
     * @param incidentId The UUID the incident.
     * @param body Incident Payload.
     */
    PromiseIncidentsApi.prototype.updateIncident = function (incidentId, body, options) {
        var result = this.api.updateIncident(incidentId, body, options);
        return result.toPromise();
    };
    return PromiseIncidentsApi;
}());
exports.PromiseIncidentsApi = PromiseIncidentsApi;
var ObservableAPI_5 = require("./ObservableAPI");
var PromiseKeyManagementApi = /** @class */ (function () {
    function PromiseKeyManagementApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_5.ObservableKeyManagementApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Create an API key.
     * Create an API key
     * @param body
     */
    PromiseKeyManagementApi.prototype.createAPIKey = function (body, options) {
        var result = this.api.createAPIKey(body, options);
        return result.toPromise();
    };
    /**
     * Create an application key for current user
     * Create an application key for current user
     * @param body
     */
    PromiseKeyManagementApi.prototype.createCurrentUserApplicationKey = function (body, options) {
        var result = this.api.createCurrentUserApplicationKey(body, options);
        return result.toPromise();
    };
    /**
     * Delete an API key.
     * Delete an API key
     * @param apiKeyId The ID of the API key.
     */
    PromiseKeyManagementApi.prototype.deleteAPIKey = function (apiKeyId, options) {
        var result = this.api.deleteAPIKey(apiKeyId, options);
        return result.toPromise();
    };
    /**
     * Delete an application key
     * Delete an application key
     * @param appKeyId The ID of the application key.
     */
    PromiseKeyManagementApi.prototype.deleteApplicationKey = function (appKeyId, options) {
        var result = this.api.deleteApplicationKey(appKeyId, options);
        return result.toPromise();
    };
    /**
     * Delete an application key owned by current user
     * Delete an application key owned by current user
     * @param appKeyId The ID of the application key.
     */
    PromiseKeyManagementApi.prototype.deleteCurrentUserApplicationKey = function (appKeyId, options) {
        var result = this.api.deleteCurrentUserApplicationKey(appKeyId, options);
        return result.toPromise();
    };
    /**
     * Get an API key.
     * Get API key
     * @param apiKeyId The ID of the API key.
     * @param include Comma separated list of resource paths for related resources to include in the response. Supported resource paths are &#x60;created_by&#x60; and &#x60;modified_by&#x60;.
     */
    PromiseKeyManagementApi.prototype.getAPIKey = function (apiKeyId, include, options) {
        var result = this.api.getAPIKey(apiKeyId, include, options);
        return result.toPromise();
    };
    /**
     * Get an application key owned by current user
     * Get one application key owned by current user
     * @param appKeyId The ID of the application key.
     */
    PromiseKeyManagementApi.prototype.getCurrentUserApplicationKey = function (appKeyId, options) {
        var result = this.api.getCurrentUserApplicationKey(appKeyId, options);
        return result.toPromise();
    };
    /**
     * List all API keys available for your account.
     * Get all API keys
     * @param pageSize Size for a given page.
     * @param pageNumber Specific page number to return.
     * @param sort API key attribute used to sort results. Sort order is ascending by default. In order to specify a descending sort, prefix the attribute with a minus sign.
     * @param filter Filter API keys by the specified string.
     * @param filterCreatedAtStart Only include API keys created on or after the specified date.
     * @param filterCreatedAtEnd Only include API keys created on or before the specified date.
     * @param filterModifiedAtStart Only include API keys modified on or after the specified date.
     * @param filterModifiedAtEnd Only include API keys modified on or before the specified date.
     * @param include Comma separated list of resource paths for related resources to include in the response. Supported resource paths are &#x60;created_by&#x60; and &#x60;modified_by&#x60;.
     */
    PromiseKeyManagementApi.prototype.listAPIKeys = function (pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, filterModifiedAtStart, filterModifiedAtEnd, include, options) {
        var result = this.api.listAPIKeys(pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, filterModifiedAtStart, filterModifiedAtEnd, include, options);
        return result.toPromise();
    };
    /**
     * List all application keys available for your org
     * Get all application keys
     * @param pageSize Size for a given page.
     * @param pageNumber Specific page number to return.
     * @param sort Application key attribute used to sort results. Sort order is ascending by default. In order to specify a descending sort, prefix the attribute with a minus sign.
     * @param filter Filter application keys by the specified string.
     * @param filterCreatedAtStart Only include application keys created on or after the specified date.
     * @param filterCreatedAtEnd Only include application keys created on or before the specified date.
     */
    PromiseKeyManagementApi.prototype.listApplicationKeys = function (pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, options) {
        var result = this.api.listApplicationKeys(pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, options);
        return result.toPromise();
    };
    /**
     * List all application keys available for current user
     * Get all application keys owned by current user
     * @param pageSize Size for a given page.
     * @param pageNumber Specific page number to return.
     * @param sort Application key attribute used to sort results. Sort order is ascending by default. In order to specify a descending sort, prefix the attribute with a minus sign.
     * @param filter Filter application keys by the specified string.
     * @param filterCreatedAtStart Only include application keys created on or after the specified date.
     * @param filterCreatedAtEnd Only include application keys created on or before the specified date.
     */
    PromiseKeyManagementApi.prototype.listCurrentUserApplicationKeys = function (pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, options) {
        var result = this.api.listCurrentUserApplicationKeys(pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, options);
        return result.toPromise();
    };
    /**
     * Update an API key.
     * Edit an API key
     * @param apiKeyId The ID of the API key.
     * @param body
     */
    PromiseKeyManagementApi.prototype.updateAPIKey = function (apiKeyId, body, options) {
        var result = this.api.updateAPIKey(apiKeyId, body, options);
        return result.toPromise();
    };
    /**
     * Edit an application key
     * Edit an application key
     * @param appKeyId The ID of the application key.
     * @param body
     */
    PromiseKeyManagementApi.prototype.updateApplicationKey = function (appKeyId, body, options) {
        var result = this.api.updateApplicationKey(appKeyId, body, options);
        return result.toPromise();
    };
    /**
     * Edit an application key owned by current user
     * Edit an application key owned by current user
     * @param appKeyId The ID of the application key.
     * @param body
     */
    PromiseKeyManagementApi.prototype.updateCurrentUserApplicationKey = function (appKeyId, body, options) {
        var result = this.api.updateCurrentUserApplicationKey(appKeyId, body, options);
        return result.toPromise();
    };
    return PromiseKeyManagementApi;
}());
exports.PromiseKeyManagementApi = PromiseKeyManagementApi;
var ObservableAPI_6 = require("./ObservableAPI");
var PromiseLogsApi = /** @class */ (function () {
    function PromiseLogsApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_6.ObservableLogsApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * The API endpoint to aggregate events into buckets and compute metrics and timeseries.
     * Aggregate events
     * @param body
     */
    PromiseLogsApi.prototype.aggregateLogs = function (body, options) {
        var result = this.api.aggregateLogs(body, options);
        return result.toPromise();
    };
    /**
     * List endpoint returns logs that match a log search query. [Results are paginated][1].  Use this endpoint to build complex logs filtering and search.  **If you are considering archiving logs for your organization, consider use of the Datadog archive capabilities instead of the log list API. See [Datadog Logs Archive documentation][2].**  [1]: /logs/guide/collect-multiple-logs-with-pagination [2]: https://docs.datadoghq.com/logs/archives
     * Search logs
     * @param body
     */
    PromiseLogsApi.prototype.listLogs = function (body, options) {
        var result = this.api.listLogs(body, options);
        return result.toPromise();
    };
    /**
     * List endpoint returns logs that match a log search query. [Results are paginated][1].  Use this endpoint to see your latest logs.  **If you are considering archiving logs for your organization, consider use of the Datadog archive capabilities instead of the log list API. See [Datadog Logs Archive documentation][2].**  [1]: /logs/guide/collect-multiple-logs-with-pagination [2]: https://docs.datadoghq.com/logs/archives
     * Get a list of logs
     * @param filterQuery Search query following logs syntax.
     * @param filterIndex For customers with multiple indexes, the indexes to search Defaults to &#39;*&#39; which means all indexes
     * @param filterFrom Minimum timestamp for requested logs.
     * @param filterTo Maximum timestamp for requested logs.
     * @param sort Order of logs in results.
     * @param pageCursor List following results with a cursor provided in the previous query.
     * @param pageLimit Maximum number of logs in the response.
     */
    PromiseLogsApi.prototype.listLogsGet = function (filterQuery, filterIndex, filterFrom, filterTo, sort, pageCursor, pageLimit, options) {
        var result = this.api.listLogsGet(filterQuery, filterIndex, filterFrom, filterTo, sort, pageCursor, pageLimit, options);
        return result.toPromise();
    };
    return PromiseLogsApi;
}());
exports.PromiseLogsApi = PromiseLogsApi;
var ObservableAPI_7 = require("./ObservableAPI");
var PromiseLogsArchivesApi = /** @class */ (function () {
    function PromiseLogsArchivesApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_7.ObservableLogsArchivesApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Adds a read role to an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
     * Grant role to an archive
     * @param archiveId The ID of the archive.
     * @param body
     */
    PromiseLogsArchivesApi.prototype.addReadRoleToArchive = function (archiveId, body, options) {
        var result = this.api.addReadRoleToArchive(archiveId, body, options);
        return result.toPromise();
    };
    /**
     * Create an archive in your organization.
     * Create an archive
     * @param body The definition of the new archive.
     */
    PromiseLogsArchivesApi.prototype.createLogsArchive = function (body, options) {
        var result = this.api.createLogsArchive(body, options);
        return result.toPromise();
    };
    /**
     * Delete a given archive from your organization.
     * Delete an archive
     * @param archiveId The ID of the archive.
     */
    PromiseLogsArchivesApi.prototype.deleteLogsArchive = function (archiveId, options) {
        var result = this.api.deleteLogsArchive(archiveId, options);
        return result.toPromise();
    };
    /**
     * Get a specific archive from your organization.
     * Get an archive
     * @param archiveId The ID of the archive.
     */
    PromiseLogsArchivesApi.prototype.getLogsArchive = function (archiveId, options) {
        var result = this.api.getLogsArchive(archiveId, options);
        return result.toPromise();
    };
    /**
     * Get the current order of your archives. This endpoint takes no JSON arguments.
     * Get archive order
     */
    PromiseLogsArchivesApi.prototype.getLogsArchiveOrder = function (options) {
        var result = this.api.getLogsArchiveOrder(options);
        return result.toPromise();
    };
    /**
     * Returns all read roles a given archive is restricted to.
     * List read roles for an archive
     * @param archiveId The ID of the archive.
     */
    PromiseLogsArchivesApi.prototype.listArchiveReadRoles = function (archiveId, options) {
        var result = this.api.listArchiveReadRoles(archiveId, options);
        return result.toPromise();
    };
    /**
     * Get the list of configured logs archives with their definitions.
     * Get all archives
     */
    PromiseLogsArchivesApi.prototype.listLogsArchives = function (options) {
        var result = this.api.listLogsArchives(options);
        return result.toPromise();
    };
    /**
     * Removes a role from an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
     * Revoke role from an archive
     * @param archiveId The ID of the archive.
     * @param body
     */
    PromiseLogsArchivesApi.prototype.removeRoleFromArchive = function (archiveId, body, options) {
        var result = this.api.removeRoleFromArchive(archiveId, body, options);
        return result.toPromise();
    };
    /**
     * Update a given archive configuration.  **Note**: Using this method updates your archive configuration by **replacing** your current configuration with the new one sent to your Datadog organization.
     * Update an archive
     * @param archiveId The ID of the archive.
     * @param body New definition of the archive.
     */
    PromiseLogsArchivesApi.prototype.updateLogsArchive = function (archiveId, body, options) {
        var result = this.api.updateLogsArchive(archiveId, body, options);
        return result.toPromise();
    };
    /**
     * Update the order of your archives. Since logs are processed sequentially, reordering an archive may change the structure and content of the data processed by other archives.  **Note**: Using the `PUT` method updates your archive's order by replacing the current order with the new one.
     * Update archive order
     * @param body An object containing the new ordered list of archive IDs.
     */
    PromiseLogsArchivesApi.prototype.updateLogsArchiveOrder = function (body, options) {
        var result = this.api.updateLogsArchiveOrder(body, options);
        return result.toPromise();
    };
    return PromiseLogsArchivesApi;
}());
exports.PromiseLogsArchivesApi = PromiseLogsArchivesApi;
var ObservableAPI_8 = require("./ObservableAPI");
var PromiseLogsMetricsApi = /** @class */ (function () {
    function PromiseLogsMetricsApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_8.ObservableLogsMetricsApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Create a metric based on your ingested logs in your organization. Returns the log-based metric object from the request body when the request is successful.
     * Create a log-based metric
     * @param body The definition of the new log-based metric.
     */
    PromiseLogsMetricsApi.prototype.createLogsMetric = function (body, options) {
        var result = this.api.createLogsMetric(body, options);
        return result.toPromise();
    };
    /**
     * Delete a specific log-based metric from your organization.
     * Delete a log-based metric
     * @param metricId The name of the log-based metric.
     */
    PromiseLogsMetricsApi.prototype.deleteLogsMetric = function (metricId, options) {
        var result = this.api.deleteLogsMetric(metricId, options);
        return result.toPromise();
    };
    /**
     * Get a specific log-based metric from your organization.
     * Get a log-based metric
     * @param metricId The name of the log-based metric.
     */
    PromiseLogsMetricsApi.prototype.getLogsMetric = function (metricId, options) {
        var result = this.api.getLogsMetric(metricId, options);
        return result.toPromise();
    };
    /**
     * Get the list of configured log-based metrics with their definitions.
     * Get all log-based metrics
     */
    PromiseLogsMetricsApi.prototype.listLogsMetrics = function (options) {
        var result = this.api.listLogsMetrics(options);
        return result.toPromise();
    };
    /**
     * Update a specific log-based metric from your organization. Returns the log-based metric object from the request body when the request is successful.
     * Update a log-based metric
     * @param metricId The name of the log-based metric.
     * @param body New definition of the log-based metric.
     */
    PromiseLogsMetricsApi.prototype.updateLogsMetric = function (metricId, body, options) {
        var result = this.api.updateLogsMetric(metricId, body, options);
        return result.toPromise();
    };
    return PromiseLogsMetricsApi;
}());
exports.PromiseLogsMetricsApi = PromiseLogsMetricsApi;
var ObservableAPI_9 = require("./ObservableAPI");
var PromiseMetricsApi = /** @class */ (function () {
    function PromiseMetricsApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_9.ObservableMetricsApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Create and define a list of queryable tag keys for an existing count/gauge/rate/distribution metric. Optionally, include percentile aggregations on any distribution metric. Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
     * Create a tag configuration
     * @param metricName The name of the metric.
     * @param body
     */
    PromiseMetricsApi.prototype.createTagConfiguration = function (metricName, body, options) {
        var result = this.api.createTagConfiguration(metricName, body, options);
        return result.toPromise();
    };
    /**
     * Deletes a metric's tag configuration. Can only be used with application keys from users with the `Manage Tags for Metrics` permission.
     * Delete a tag configuration
     * @param metricName The name of the metric.
     */
    PromiseMetricsApi.prototype.deleteTagConfiguration = function (metricName, options) {
        var result = this.api.deleteTagConfiguration(metricName, options);
        return result.toPromise();
    };
    /**
     * Returns the tag configuration for the given metric name.
     * List tag configuration by name
     * @param metricName The name of the metric.
     */
    PromiseMetricsApi.prototype.listTagConfigurationByName = function (metricName, options) {
        var result = this.api.listTagConfigurationByName(metricName, options);
        return result.toPromise();
    };
    /**
     * Returns all configured count/gauge/rate/distribution metric names (with additional filters if specified).
     * List tag configurations
     * @param filterConfigured Filter metrics that have configured tags.
     * @param filterTagsConfigured Filter tag configurations by configured tags.
     * @param filterMetricType Filter tag configurations by metric type.
     * @param filterIncludePercentiles Filter distributions with additional percentile aggregations enabled or disabled.
     * @param filterTags Filter metrics that have been submitted with the given tags. Supports boolean and wildcard expressions. Cannot be combined with other filters.
     * @param windowSeconds The number of seconds of look back (from now) to apply to a filter[tag] query. Defaults value is 3600 (1 hour), maximum value is 172,800 (2 days).
     */
    PromiseMetricsApi.prototype.listTagConfigurations = function (filterConfigured, filterTagsConfigured, filterMetricType, filterIncludePercentiles, filterTags, windowSeconds, options) {
        var result = this.api.listTagConfigurations(filterConfigured, filterTagsConfigured, filterMetricType, filterIncludePercentiles, filterTags, windowSeconds, options);
        return result.toPromise();
    };
    /**
     * View indexed tag key-value pairs for a given metric name.
     * List tags by metric name
     * @param metricName The name of the metric.
     */
    PromiseMetricsApi.prototype.listTagsByMetricName = function (metricName, options) {
        var result = this.api.listTagsByMetricName(metricName, options);
        return result.toPromise();
    };
    /**
     * View distinct metrics volumes for the given metric name.  Custom distribution metrics will return both ingested and indexed custom metric volumes. For Metrics without Limits&trade; beta customers, all metrics will return both ingested/indexed volumes. Custom metrics generated in-app from other products will return `null` for ingested volumes.
     * List distinct metric volumes by metric name
     * @param metricName The name of the metric.
     */
    PromiseMetricsApi.prototype.listVolumesByMetricName = function (metricName, options) {
        var result = this.api.listVolumesByMetricName(metricName, options);
        return result.toPromise();
    };
    /**
     * Update the tag configuration of a metric or percentile aggregations of a distribution metric. Can only be used with application keys from users with the `Manage Tags for Metrics` permission.
     * Update a tag configuration
     * @param metricName The name of the metric.
     * @param body
     */
    PromiseMetricsApi.prototype.updateTagConfiguration = function (metricName, body, options) {
        var result = this.api.updateTagConfiguration(metricName, body, options);
        return result.toPromise();
    };
    return PromiseMetricsApi;
}());
exports.PromiseMetricsApi = PromiseMetricsApi;
var ObservableAPI_10 = require("./ObservableAPI");
var PromiseProcessesApi = /** @class */ (function () {
    function PromiseProcessesApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_10.ObservableProcessesApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Get all processes for your organization.
     * Get all processes
     * @param search String to search processes by.
     * @param tags Comma-separated list of tags to filter processes by.
     * @param from Unix timestamp (number of seconds since epoch) of the start of the query window. If not provided, the start of the query window will be 15 minutes before the &#x60;to&#x60; timestamp. If neither &#x60;from&#x60; nor &#x60;to&#x60; are provided, the query window will be &#x60;[now - 15m, now]&#x60;.
     * @param to Unix timestamp (number of seconds since epoch) of the end of the query window. If not provided, the end of the query window will be 15 minutes after the &#x60;from&#x60; timestamp. If neither &#x60;from&#x60; nor &#x60;to&#x60; are provided, the query window will be &#x60;[now - 15m, now]&#x60;.
     * @param pageLimit Maximum number of results returned.
     * @param pageCursor String to query the next page of results. This key is provided with each valid response from the API in &#x60;meta.page.after&#x60;.
     */
    PromiseProcessesApi.prototype.listProcesses = function (search, tags, from, to, pageLimit, pageCursor, options) {
        var result = this.api.listProcesses(search, tags, from, to, pageLimit, pageCursor, options);
        return result.toPromise();
    };
    return PromiseProcessesApi;
}());
exports.PromiseProcessesApi = PromiseProcessesApi;
var ObservableAPI_11 = require("./ObservableAPI");
var PromiseRolesApi = /** @class */ (function () {
    function PromiseRolesApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_11.ObservableRolesApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Adds a permission to a role.
     * Grant permission to a role
     * @param roleId The ID of the role.
     * @param body
     */
    PromiseRolesApi.prototype.addPermissionToRole = function (roleId, body, options) {
        var result = this.api.addPermissionToRole(roleId, body, options);
        return result.toPromise();
    };
    /**
     * Adds a user to a role.
     * Add a user to a role
     * @param roleId The ID of the role.
     * @param body
     */
    PromiseRolesApi.prototype.addUserToRole = function (roleId, body, options) {
        var result = this.api.addUserToRole(roleId, body, options);
        return result.toPromise();
    };
    /**
     * Create a new role for your organization.
     * Create role
     * @param body
     */
    PromiseRolesApi.prototype.createRole = function (body, options) {
        var result = this.api.createRole(body, options);
        return result.toPromise();
    };
    /**
     * Disables a role.
     * Delete role
     * @param roleId The ID of the role.
     */
    PromiseRolesApi.prototype.deleteRole = function (roleId, options) {
        var result = this.api.deleteRole(roleId, options);
        return result.toPromise();
    };
    /**
     * Get a role in the organization specified by the roleâ€™s `role_id`.
     * Get a role
     * @param roleId The ID of the role.
     */
    PromiseRolesApi.prototype.getRole = function (roleId, options) {
        var result = this.api.getRole(roleId, options);
        return result.toPromise();
    };
    /**
     * Returns a list of all permissions, including name, description, and ID.
     * List permissions
     */
    PromiseRolesApi.prototype.listPermissions = function (options) {
        var result = this.api.listPermissions(options);
        return result.toPromise();
    };
    /**
     * Returns a list of all permissions for a single role.
     * List permissions for a role
     * @param roleId The ID of the role.
     */
    PromiseRolesApi.prototype.listRolePermissions = function (roleId, options) {
        var result = this.api.listRolePermissions(roleId, options);
        return result.toPromise();
    };
    /**
     * Gets all users of a role.
     * Get all users of a role
     * @param roleId The ID of the role.
     * @param pageSize Size for a given page.
     * @param pageNumber Specific page number to return.
     * @param sort User attribute to order results by. Sort order is **ascending** by default. Sort order is **descending** if the field is prefixed by a negative sign, for example &#x60;sort&#x3D;-name&#x60;. Options: &#x60;name&#x60;, &#x60;email&#x60;, &#x60;status&#x60;.
     * @param filter Filter all users by the given string. Defaults to no filtering.
     */
    PromiseRolesApi.prototype.listRoleUsers = function (roleId, pageSize, pageNumber, sort, filter, options) {
        var result = this.api.listRoleUsers(roleId, pageSize, pageNumber, sort, filter, options);
        return result.toPromise();
    };
    /**
     * Returns all roles, including their names and IDs.
     * List roles
     * @param pageSize Size for a given page.
     * @param pageNumber Specific page number to return.
     * @param sort Sort roles depending on the given field. Sort order is **ascending** by default. Sort order is **descending** if the field is prefixed by a negative sign, for example: &#x60;sort&#x3D;-name&#x60;.
     * @param filter Filter all roles by the given string.
     */
    PromiseRolesApi.prototype.listRoles = function (pageSize, pageNumber, sort, filter, options) {
        var result = this.api.listRoles(pageSize, pageNumber, sort, filter, options);
        return result.toPromise();
    };
    /**
     * Removes a permission from a role.
     * Revoke permission
     * @param roleId The ID of the role.
     * @param body
     */
    PromiseRolesApi.prototype.removePermissionFromRole = function (roleId, body, options) {
        var result = this.api.removePermissionFromRole(roleId, body, options);
        return result.toPromise();
    };
    /**
     * Removes a user from a role.
     * Remove a user from a role
     * @param roleId The ID of the role.
     * @param body
     */
    PromiseRolesApi.prototype.removeUserFromRole = function (roleId, body, options) {
        var result = this.api.removeUserFromRole(roleId, body, options);
        return result.toPromise();
    };
    /**
     * Edit a role. Can only be used with application keys belonging to administrators.
     * Update a role
     * @param roleId The ID of the role.
     * @param body
     */
    PromiseRolesApi.prototype.updateRole = function (roleId, body, options) {
        var result = this.api.updateRole(roleId, body, options);
        return result.toPromise();
    };
    return PromiseRolesApi;
}());
exports.PromiseRolesApi = PromiseRolesApi;
var ObservableAPI_12 = require("./ObservableAPI");
var PromiseSecurityMonitoringApi = /** @class */ (function () {
    function PromiseSecurityMonitoringApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_12.ObservableSecurityMonitoringApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Create a security filter.  See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/) for more examples.
     * Create a security filter
     * @param body The definition of the new security filter.
     */
    PromiseSecurityMonitoringApi.prototype.createSecurityFilter = function (body, options) {
        var result = this.api.createSecurityFilter(body, options);
        return result.toPromise();
    };
    /**
     * Create a detection rule.
     * Create a detection rule
     * @param body
     */
    PromiseSecurityMonitoringApi.prototype.createSecurityMonitoringRule = function (body, options) {
        var result = this.api.createSecurityMonitoringRule(body, options);
        return result.toPromise();
    };
    /**
     * Delete a specific security filter.
     * Delete a security filter
     * @param securityFilterId The ID of the security filter.
     */
    PromiseSecurityMonitoringApi.prototype.deleteSecurityFilter = function (securityFilterId, options) {
        var result = this.api.deleteSecurityFilter(securityFilterId, options);
        return result.toPromise();
    };
    /**
     * Delete an existing rule. Default rules cannot be deleted.
     * Delete an existing rule
     * @param ruleId The ID of the rule.
     */
    PromiseSecurityMonitoringApi.prototype.deleteSecurityMonitoringRule = function (ruleId, options) {
        var result = this.api.deleteSecurityMonitoringRule(ruleId, options);
        return result.toPromise();
    };
    /**
     * Get the details of a specific security filter.  See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/) for more examples.
     * Get a security filter
     * @param securityFilterId The ID of the security filter.
     */
    PromiseSecurityMonitoringApi.prototype.getSecurityFilter = function (securityFilterId, options) {
        var result = this.api.getSecurityFilter(securityFilterId, options);
        return result.toPromise();
    };
    /**
     * Get a rule's details.
     * Get a rule's details
     * @param ruleId The ID of the rule.
     */
    PromiseSecurityMonitoringApi.prototype.getSecurityMonitoringRule = function (ruleId, options) {
        var result = this.api.getSecurityMonitoringRule(ruleId, options);
        return result.toPromise();
    };
    /**
     * Get the list of configured security filters with their definitions.
     * Get all security filters
     */
    PromiseSecurityMonitoringApi.prototype.listSecurityFilters = function (options) {
        var result = this.api.listSecurityFilters(options);
        return result.toPromise();
    };
    /**
     * List rules.
     * List rules
     * @param pageSize Size for a given page.
     * @param pageNumber Specific page number to return.
     */
    PromiseSecurityMonitoringApi.prototype.listSecurityMonitoringRules = function (pageSize, pageNumber, options) {
        var result = this.api.listSecurityMonitoringRules(pageSize, pageNumber, options);
        return result.toPromise();
    };
    /**
     * The list endpoint returns security signals that match a search query. Both this endpoint and the POST endpoint can be used interchangeably when listing security signals.
     * Get a quick list of security signals
     * @param filterQuery The search query for security signals.
     * @param filterFrom The minimum timestamp for requested security signals.
     * @param filterTo The maximum timestamp for requested security signals.
     * @param sort The order of the security signals in results.
     * @param pageCursor A list of results using the cursor provided in the previous query.
     * @param pageLimit The maximum number of security signals in the response.
     */
    PromiseSecurityMonitoringApi.prototype.listSecurityMonitoringSignals = function (filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, options) {
        var result = this.api.listSecurityMonitoringSignals(filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, options);
        return result.toPromise();
    };
    /**
     * Returns security signals that match a search query. Both this endpoint and the GET endpoint can be used interchangeably for listing security signals.
     * Get a list of security signals
     * @param body
     */
    PromiseSecurityMonitoringApi.prototype.searchSecurityMonitoringSignals = function (body, options) {
        var result = this.api.searchSecurityMonitoringSignals(body, options);
        return result.toPromise();
    };
    /**
     * Update a specific security filter. Returns the security filter object when the request is successful.
     * Update a security filter
     * @param securityFilterId The ID of the security filter.
     * @param body New definition of the security filter.
     */
    PromiseSecurityMonitoringApi.prototype.updateSecurityFilter = function (securityFilterId, body, options) {
        var result = this.api.updateSecurityFilter(securityFilterId, body, options);
        return result.toPromise();
    };
    /**
     * Update an existing rule. When updating `cases`, `queries` or `options`, the whole field must be included. For example, when modifying a query all queries must be included. Default rules can only be updated to be enabled and to change notifications.
     * Update an existing rule
     * @param ruleId The ID of the rule.
     * @param body
     */
    PromiseSecurityMonitoringApi.prototype.updateSecurityMonitoringRule = function (ruleId, body, options) {
        var result = this.api.updateSecurityMonitoringRule(ruleId, body, options);
        return result.toPromise();
    };
    return PromiseSecurityMonitoringApi;
}());
exports.PromiseSecurityMonitoringApi = PromiseSecurityMonitoringApi;
var ObservableAPI_13 = require("./ObservableAPI");
var PromiseUsersApi = /** @class */ (function () {
    function PromiseUsersApi(configuration, requestFactory, responseProcessor) {
        this.api = new ObservableAPI_13.ObservableUsersApi(configuration, requestFactory, responseProcessor);
    }
    /**
     * Create a user for your organization.
     * Create a user
     * @param body
     */
    PromiseUsersApi.prototype.createUser = function (body, options) {
        var result = this.api.createUser(body, options);
        return result.toPromise();
    };
    /**
     * Disable a user. Can only be used with an application key belonging to an administrator user.
     * Disable a user
     * @param userId The ID of the user.
     */
    PromiseUsersApi.prototype.disableUser = function (userId, options) {
        var result = this.api.disableUser(userId, options);
        return result.toPromise();
    };
    /**
     * Returns a single user invitation by its UUID.
     * Get a user invitation
     * @param userInvitationUuid The UUID of the user invitation.
     */
    PromiseUsersApi.prototype.getInvitation = function (userInvitationUuid, options) {
        var result = this.api.getInvitation(userInvitationUuid, options);
        return result.toPromise();
    };
    /**
     * Get a user in the organization specified by the userâ€™s `user_id`.
     * Get user details
     * @param userId The ID of the user.
     */
    PromiseUsersApi.prototype.getUser = function (userId, options) {
        var result = this.api.getUser(userId, options);
        return result.toPromise();
    };
    /**
     * Get a user organization. Returns the user information and all organizations joined by this user.
     * Get a user organization
     * @param userId The ID of the user.
     */
    PromiseUsersApi.prototype.listUserOrganizations = function (userId, options) {
        var result = this.api.listUserOrganizations(userId, options);
        return result.toPromise();
    };
    /**
     * Get a user permission set. Returns a list of the userâ€™s permissions granted by the associated user's roles.
     * Get a user permissions
     * @param userId The ID of the user.
     */
    PromiseUsersApi.prototype.listUserPermissions = function (userId, options) {
        var result = this.api.listUserPermissions(userId, options);
        return result.toPromise();
    };
    /**
     * Get the list of all users in the organization. This list includes all users even if they are deactivated or unverified.
     * List all users
     * @param pageSize Size for a given page.
     * @param pageNumber Specific page number to return.
     * @param sort User attribute to order results by. Sort order is ascending by default. Sort order is descending if the field is prefixed by a negative sign, for example &#x60;sort&#x3D;-name&#x60;. Options: &#x60;name&#x60;, &#x60;modified_at&#x60;, &#x60;user_count&#x60;.
     * @param sortDir Direction of sort. Options: &#x60;asc&#x60;, &#x60;desc&#x60;.
     * @param filter Filter all users by the given string. Defaults to no filtering.
     * @param filterStatus Filter on status attribute. Comma separated list, with possible values &#x60;Active&#x60;, &#x60;Pending&#x60;, and &#x60;Disabled&#x60;. Defaults to no filtering.
     */
    PromiseUsersApi.prototype.listUsers = function (pageSize, pageNumber, sort, sortDir, filter, filterStatus, options) {
        var result = this.api.listUsers(pageSize, pageNumber, sort, sortDir, filter, filterStatus, options);
        return result.toPromise();
    };
    /**
     * Sends emails to one or more users inviting them to join the organization.
     * Send invitation emails
     * @param body
     */
    PromiseUsersApi.prototype.sendInvitations = function (body, options) {
        var result = this.api.sendInvitations(body, options);
        return result.toPromise();
    };
    /**
     * Edit a user. Can only be used with an application key belonging to an administrator user.
     * Update a user
     * @param userId The ID of the user.
     * @param body
     */
    PromiseUsersApi.prototype.updateUser = function (userId, body, options) {
        var result = this.api.updateUser(userId, body, options);
        return result.toPromise();
    };
    return PromiseUsersApi;
}());
exports.PromiseUsersApi = PromiseUsersApi;
//# sourceMappingURL=PromiseAPI.js.map