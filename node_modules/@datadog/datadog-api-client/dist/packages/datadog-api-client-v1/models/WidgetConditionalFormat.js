"use strict";
/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WidgetConditionalFormat = void 0;
var ObjectSerializer_1 = require("./ObjectSerializer");
/**
* Define a conditional format for the widget.
*/
var WidgetConditionalFormat = /** @class */ (function () {
    function WidgetConditionalFormat() {
    }
    WidgetConditionalFormat.getAttributeTypeMap = function () {
        return WidgetConditionalFormat.attributeTypeMap;
    };
    WidgetConditionalFormat.deserialize = function (data) {
        var res = new WidgetConditionalFormat();
        if (data.comparator === undefined) {
            throw new TypeError("missing required attribute 'comparator' on 'WidgetConditionalFormat' object");
        }
        if (['>', '>=', '<', '<=', undefined].includes(data.comparator)) {
            res.comparator = data.comparator;
        }
        else {
            throw TypeError("invalid enum value " + data.comparator + " for comparator");
        }
        res.customBgColor = ObjectSerializer_1.ObjectSerializer.deserialize(data.custom_bg_color, "string", "");
        res.customFgColor = ObjectSerializer_1.ObjectSerializer.deserialize(data.custom_fg_color, "string", "");
        res.hideValue = ObjectSerializer_1.ObjectSerializer.deserialize(data.hide_value, "boolean", "");
        res.imageUrl = ObjectSerializer_1.ObjectSerializer.deserialize(data.image_url, "string", "");
        res.metric = ObjectSerializer_1.ObjectSerializer.deserialize(data.metric, "string", "");
        if (data.palette === undefined) {
            throw new TypeError("missing required attribute 'palette' on 'WidgetConditionalFormat' object");
        }
        if (['blue', 'custom_bg', 'custom_image', 'custom_text', 'gray_on_white', 'grey', 'green', 'orange', 'red', 'red_on_white', 'white_on_gray', 'white_on_green', 'green_on_white', 'white_on_red', 'white_on_yellow', 'yellow_on_white', 'black_on_light_yellow', 'black_on_light_green', 'black_on_light_red', undefined].includes(data.palette)) {
            res.palette = data.palette;
        }
        else {
            throw TypeError("invalid enum value " + data.palette + " for palette");
        }
        res.timeframe = ObjectSerializer_1.ObjectSerializer.deserialize(data.timeframe, "string", "");
        if (data.value === undefined) {
            throw new TypeError("missing required attribute 'value' on 'WidgetConditionalFormat' object");
        }
        res.value = ObjectSerializer_1.ObjectSerializer.deserialize(data.value, "number", "double");
        return res;
    };
    WidgetConditionalFormat.serialize = function (data) {
        var attributeTypes = WidgetConditionalFormat.getAttributeTypeMap();
        var res = {};
        for (var _i = 0, _a = Object.entries(data); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (!(key in attributeTypes)) {
                throw new TypeError(key + " attribute not in schema");
            }
        }
        if (data.comparator === undefined) {
            throw new TypeError("missing required attribute 'comparator' on 'WidgetConditionalFormat' object");
        }
        if (['>', '>=', '<', '<=', undefined].includes(data.comparator)) {
            res.comparator = data.comparator;
        }
        else {
            throw TypeError("invalid enum value " + data.comparator + " for comparator");
        }
        res.custom_bg_color = ObjectSerializer_1.ObjectSerializer.serialize(data.customBgColor, "string", "");
        res.custom_fg_color = ObjectSerializer_1.ObjectSerializer.serialize(data.customFgColor, "string", "");
        res.hide_value = ObjectSerializer_1.ObjectSerializer.serialize(data.hideValue, "boolean", "");
        res.image_url = ObjectSerializer_1.ObjectSerializer.serialize(data.imageUrl, "string", "");
        res.metric = ObjectSerializer_1.ObjectSerializer.serialize(data.metric, "string", "");
        if (data.palette === undefined) {
            throw new TypeError("missing required attribute 'palette' on 'WidgetConditionalFormat' object");
        }
        if (['blue', 'custom_bg', 'custom_image', 'custom_text', 'gray_on_white', 'grey', 'green', 'orange', 'red', 'red_on_white', 'white_on_gray', 'white_on_green', 'green_on_white', 'white_on_red', 'white_on_yellow', 'yellow_on_white', 'black_on_light_yellow', 'black_on_light_green', 'black_on_light_red', undefined].includes(data.palette)) {
            res.palette = data.palette;
        }
        else {
            throw TypeError("invalid enum value " + data.palette + " for palette");
        }
        res.timeframe = ObjectSerializer_1.ObjectSerializer.serialize(data.timeframe, "string", "");
        if (data.value === undefined) {
            throw new TypeError("missing required attribute 'value' on 'WidgetConditionalFormat' object");
        }
        res.value = ObjectSerializer_1.ObjectSerializer.serialize(data.value, "number", "double");
        return res;
    };
    WidgetConditionalFormat.discriminator = undefined;
    WidgetConditionalFormat.attributeTypeMap = {
        "comparator": {
            "baseName": "comparator",
            "type": "WidgetComparator",
            "format": ""
        },
        "customBgColor": {
            "baseName": "custom_bg_color",
            "type": "string",
            "format": ""
        },
        "customFgColor": {
            "baseName": "custom_fg_color",
            "type": "string",
            "format": ""
        },
        "hideValue": {
            "baseName": "hide_value",
            "type": "boolean",
            "format": ""
        },
        "imageUrl": {
            "baseName": "image_url",
            "type": "string",
            "format": ""
        },
        "metric": {
            "baseName": "metric",
            "type": "string",
            "format": ""
        },
        "palette": {
            "baseName": "palette",
            "type": "WidgetPalette",
            "format": ""
        },
        "timeframe": {
            "baseName": "timeframe",
            "type": "string",
            "format": ""
        },
        "value": {
            "baseName": "value",
            "type": "number",
            "format": "double"
        }
    };
    return WidgetConditionalFormat;
}());
exports.WidgetConditionalFormat = WidgetConditionalFormat;
//# sourceMappingURL=WidgetConditionalFormat.js.map