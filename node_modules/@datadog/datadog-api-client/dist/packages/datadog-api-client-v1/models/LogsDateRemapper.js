"use strict";
/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogsDateRemapper = void 0;
var ObjectSerializer_1 = require("./ObjectSerializer");
/**
* As Datadog receives logs, it timestamps them using the value(s) from any of these default attributes.    - `timestamp`   - `date`   - `_timestamp`   - `Timestamp`   - `eventTime`   - `published_date`    If your logs put their dates in an attribute not in this list,   use the log date Remapper Processor to define their date attribute as the official log timestamp.   The recognized date formats are ISO8601, UNIX (the milliseconds EPOCH format), and RFC3164.    **Note:** If your logs don’t contain any of the default attributes   and you haven’t defined your own date attribute, Datadog timestamps   the logs with the date it received them.    If multiple log date remapper processors can be applied to a given log,   only the first one (according to the pipelines order) is taken into account.
*/
var LogsDateRemapper = /** @class */ (function () {
    function LogsDateRemapper() {
    }
    LogsDateRemapper.getAttributeTypeMap = function () {
        return LogsDateRemapper.attributeTypeMap;
    };
    LogsDateRemapper.deserialize = function (data) {
        var res = new LogsDateRemapper();
        res.isEnabled = ObjectSerializer_1.ObjectSerializer.deserialize(data.is_enabled, "boolean", "");
        res.name = ObjectSerializer_1.ObjectSerializer.deserialize(data.name, "string", "");
        if (data.sources === undefined) {
            throw new TypeError("missing required attribute 'sources' on 'LogsDateRemapper' object");
        }
        res.sources = ObjectSerializer_1.ObjectSerializer.deserialize(data.sources, "Array<string>", "");
        if (data.type === undefined) {
            throw new TypeError("missing required attribute 'type' on 'LogsDateRemapper' object");
        }
        if (['date-remapper', undefined].includes(data.type)) {
            res.type = data.type;
        }
        else {
            throw TypeError("invalid enum value " + data.type + " for type");
        }
        return res;
    };
    LogsDateRemapper.serialize = function (data) {
        var attributeTypes = LogsDateRemapper.getAttributeTypeMap();
        var res = {};
        for (var _i = 0, _a = Object.entries(data); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (!(key in attributeTypes)) {
                throw new TypeError(key + " attribute not in schema");
            }
        }
        res.is_enabled = ObjectSerializer_1.ObjectSerializer.serialize(data.isEnabled, "boolean", "");
        res.name = ObjectSerializer_1.ObjectSerializer.serialize(data.name, "string", "");
        if (data.sources === undefined) {
            throw new TypeError("missing required attribute 'sources' on 'LogsDateRemapper' object");
        }
        res.sources = ObjectSerializer_1.ObjectSerializer.serialize(data.sources, "Array<string>", "");
        if (data.type === undefined) {
            throw new TypeError("missing required attribute 'type' on 'LogsDateRemapper' object");
        }
        if (['date-remapper', undefined].includes(data.type)) {
            res.type = data.type;
        }
        else {
            throw TypeError("invalid enum value " + data.type + " for type");
        }
        return res;
    };
    LogsDateRemapper.discriminator = undefined;
    LogsDateRemapper.attributeTypeMap = {
        "isEnabled": {
            "baseName": "is_enabled",
            "type": "boolean",
            "format": ""
        },
        "name": {
            "baseName": "name",
            "type": "string",
            "format": ""
        },
        "sources": {
            "baseName": "sources",
            "type": "Array<string>",
            "format": ""
        },
        "type": {
            "baseName": "type",
            "type": "LogsDateRemapperType",
            "format": ""
        }
    };
    return LogsDateRemapper;
}());
exports.LogsDateRemapper = LogsDateRemapper;
//# sourceMappingURL=LogsDateRemapper.js.map